// MARK: Background
fun InitBackground() {
    // Needs to be a global variable, otherwise it is destroyed when the function returns
    global.gBackground;

    gBackground.Z = 1;

    gBackground.image = Image("bg.png").Scale(Window.GetWidth(), Window.GetHeight());
    gBackground.sprite = SpriteNew();
    gBackground.sprite.SetImage(gBackground.image);
    gBackground.sprite.SetPosition(Window.GetX(), Window.GetY(), gBackground.Z);
}

// MARK: Terminal
fun InitTerminal() {
    global.gTerminal;

    // Set up constants
    gTerminal.FONT = "monospace 18";  // Number = font size (Use a mono font!)
    gTerminal.R = 184 / 255;  // [0.0-1.0]
    gTerminal.G = 123 / 255;  // [0.0-1.0]
    gTerminal.B = 35 / 255;  // [0.0-1.0]
    gTerminal.A = 1.0;  // [0.0-1.0]

    gTerminal.LINE_WIDTH = 148;  // Characters
    gTerminal.LINE_COUNT = 51;

    gTerminal.Z = 2;
    gTerminal.X_FACTOR = 3.5 / 100;  // [0.0-1.0] (ratio of screen)
    gTerminal.Y_FACTOR = 5 / 100;  // [0.0-1.0] (ratio of screen)
    gTerminal.LINE_SPACING_FACTOR = 0.74;

    gTerminal.TEXT_PREVIEW = 0;  // bool: Fills the screen with text to help adjust the text settings

    gTerminal.SHOW_BULLETS = 1;  // bool: Whether to show the bullet characters (this exposes the length of the password)
    gTerminal.BULLET_CHAR = "*";

    gTerminal.INTERACTIVE_LINE_COUNT = 2;  // Number of lines from the bottom which are handled specially in interactive mode
    gTerminal.INTERACTIVE_PREFIX = "> ";  // Prefix of the user input line
    gTerminal.REFRESH_FREQ = 50;  // Refresh frequency in Hz (this is decided by Plymouth, the constant is only for calculating with it)
    gTerminal.CURSOR_ENABLED = 1;  // bool: Whether to display the blinking cursor
    gTerminal.CURSOR_BLINK_FREQ = 3;  // (0<) The cursor's blink frequency in Hz (in interactive mode)
    gTerminal.CURSOR_CHAR = "_";

    gTerminal._cursorTimer = 0;
    gTerminal._interactiveLine = "";
    gTerminal._isCursorVisible = 0;
    gTerminal._isInteractive = 0;

    // Shouldn't be an empty string, because then when converted to an image,
    // it will have 0 height, causing all lines to be put in the same position
    // (Only during boot though, which is weird)
    gTerminal._initText = " ";
    if (gTerminal.TEXT_PREVIEW) {
        gTerminal._initText = "";
        for (i = 0; i < gTerminal.LINE_WIDTH; i++) {
            gTerminal._initText += "#";
        }
    }

    // Initialize sprites and their positions
    for (i = 0; i < gTerminal.LINE_COUNT; i++) {
        gTerminal._lines[i] = gTerminal._initText;
        gTerminal._sprites[i] = SpriteNew();
        DrawLine(i);
        gTerminal._sprites[i].SetPosition(
            Window.GetX() + Window.GetWidth() * gTerminal.X_FACTOR,
            Window.GetY() + Window.GetHeight() * gTerminal.Y_FACTOR + (i * gTerminal._sprites[i].GetImage().GetHeight() * gTerminal.LINE_SPACING_FACTOR),
            MSG_Z
        );
    }
}

fun TextToImage(text) {
    return Image.Text(text, gTerminal.R, gTerminal.G, gTerminal.B, gTerminal.A, gTerminal.FONT);
}

fun DrawLine(index) {
    gTerminal._sprites[index].SetImage(TextToImage(gTerminal._lines[index]));
}

fun DrawLines(count) {
    if (count == NULL) {
        count = gTerminal.LINE_COUNT;
    }
    for (i = 0; i < count; i++) {
        DrawLine(i);
    }
}

fun StringLength(string) {
    index = 0;
    string = String(string);
    while(string.CharAt(index)) index++;
    return index;
}

fun TruncateText(text) {
    if (StringLength(text) > gTerminal.LINE_WIDTH) {
        text = text.SubString(0, gTerminal.LINE_WIDTH - 3);
        text += "...";
    }
    return text;
}

fun SetLine(text, lineIndex, draw) {
    if (draw == NULL) {
        draw = 1;
    }

    text = TruncateText(text);

    gTerminal._lines[lineIndex] = text;
    if (draw) {
        DrawLine(lineIndex);
    }
}

fun AppendLine(text, lineIndex, draw) {
    if (lineIndex == NULL) {
        if (gTerminal._isInteractive) {
            // Insert before the "interactive" line
            lineIndex = gTerminal.LINE_COUNT - 1 - gTerminal.INTERACTIVE_LINE_COUNT;
        }
        else {
            // Insert at the end
            lineIndex = gTerminal.LINE_COUNT - 1;
        }
    }
    if (draw == NULL) {
        draw = 1;
    }

    // Shift messages one up until lineIndex
    for (i = 0; i < lineIndex; i++) {
        gTerminal._lines[i] = gTerminal._lines[i + 1];
    }

    SetLine(text, lineIndex, 0);

    if (draw) {
        DrawLines(lineIndex + 1);
    }
}

fun SetInteractive(isInteractive) {
    if (isInteractive == gTerminal._isInteractive){
        return;
    }
    if (isInteractive) {
        // Add empty lines which will be overwritten dynamically
        for (i = 0; i < gTerminal.INTERACTIVE_LINE_COUNT; i++) {
            AppendLine("");
        }
    }
    else {
        SetCursorVisible(0);
    }
    gTerminal._isInteractive = isInteractive;
}

fun UpdateInteractive(prompt, input) {
    SetLine(prompt, gTerminal.LINE_COUNT - 2);

    gTerminal._interactiveLine = gTerminal.INTERACTIVE_PREFIX + input;
    if (gTerminal.CURSOR_ENABLED) {
        // Here the interactive line is drawn by SetCursorVisible,
        // no need to set it beforehand
        SetCursorVisible(1);
    }
    else {
        SetLine(gTerminal._interactiveLine, gTerminal.LINE_COUNT - 1);
    }
}

fun SetCursorVisible(isVisible) {
    if (!gTerminal.CURSOR_ENABLED) {
        return;
    }
    gTerminal._cursorTimer = 0;
    gTerminal._isCursorVisible = isVisible;

    content = gTerminal._interactiveLine;

    if (gTerminal._isCursorVisible) {
        content += gTerminal.CURSOR_CHAR;
    }
    SetLine(content, gTerminal.LINE_COUNT - 1);
}

fun UpdateCursor() {
    if (!gTerminal._isInteractive || !gTerminal.CURSOR_ENABLED) {
        return;
    }

    gTerminal._cursorTimer++;
    if (gTerminal._cursorTimer >= gTerminal.REFRESH_FREQ / gTerminal.CURSOR_BLINK_FREQ) {
        SetCursorVisible(!gTerminal._isCursorVisible);
    }
}

// MARK: Callbacks
fun DisplayMessage(text) {
    AppendLine(text);
}

fun DisplayPasswordPrompt(prompt, nBullets) {
    SetInteractive(1);
    bulletStr = "";
    if (gTerminal.SHOW_BULLETS) {
        for (i = 0; i < nBullets; i++) {
            bulletStr += gTerminal.BULLET_CHAR;
        }
    }
    UpdateInteractive(prompt, bulletStr);
}

fun DisplayQuestionPrompt(prompt, input) {
    SetInteractive(1);
    UpdateInteractive(prompt, input);
}

fun DisplayNormal() {
    SetInteractive(0);
}

fun DisplayRootMounted() {
    DisplayMessage("new root mounted");
}

fun OnRefresh() {
    // Called 50 times every second according to the docs
    UpdateCursor();
}

// MARK: Main
fun Main() {
    InitBackground();
    InitTerminal();

    Plymouth.SetUpdateStatusFunction(DisplayMessage);
    Plymouth.SetMessageFunction(DisplayMessage);
    Plymouth.SetRootMountedFunction(DisplayRootMounted);
    Plymouth.SetDisplayPasswordFunction(DisplayPasswordPrompt);
    Plymouth.SetDisplayQuestionFunction(DisplayQuestionPrompt);
    Plymouth.SetDisplayNormalFunction(DisplayNormal);
    Plymouth.SetRefreshFunction(OnRefresh);
}
Main();
